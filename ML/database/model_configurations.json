{
  "neural_networks": {
    "human_behavior_prediction": {
      "architecture": {
        "input_layer": "Dense with input_dim = n_features",
        "hidden_layers": [
          "Dense(128, activation='relu', dropout=0.3)",
          "Dense(64, activation='relu', dropout=0.3)",
          "Dense(32, activation='relu', dropout=0.2)"
        ],
        "output_layer": "Dense(1, activation='sigmoid') for binary classification"
      },
      "hyperparameters": {
        "epochs": 100,
        "batch_size": 32,
        "learning_rate": 0.001,
        "optimizer": "Adam",
        "loss_function": "binary_crossentropy",
        "metrics": ["accuracy", "precision", "recall"]
      },
      "regularization": {
        "dropout": 0.3,
        "l1_regularization": 0.01,
        "l2_regularization": 0.01,
        "early_stopping": true,
        "patience": 10
      }
    },
    "molecular_property_prediction": {
      "gcn": {
        "architecture": {
          "input_dim": "Node features dimension",
          "hidden_dim": 64,
          "num_layers": 3,
          "output_dim": 1,
          "activation": "ReLU",
          "dropout": 0.3
        },
        "hyperparameters": {
          "epochs": 200,
          "batch_size": 32,
          "learning_rate": 0.01,
          "optimizer": "Adam",
          "loss_function": "binary_crossentropy"
        }
      },
      "gat": {
        "architecture": {
          "input_dim": "Node features dimension",
          "hidden_dim": 64,
          "num_heads": 8,
          "num_layers": 2,
          "output_dim": 1,
          "dropout": 0.3
        },
        "hyperparameters": {
          "epochs": 200,
          "batch_size": 32,
          "learning_rate": 0.005,
          "optimizer": "Adam",
          "loss_function": "binary_crossentropy"
        }
      },
      "transformer": {
        "architecture": {
          "input_dim": "Node features dimension",
          "hidden_dim": 128,
          "num_heads": 8,
          "num_layers": 4,
          "output_dim": 1,
          "dropout": 0.1
        },
        "hyperparameters": {
          "epochs": 300,
          "batch_size": 16,
          "learning_rate": 0.001,
          "optimizer": "AdamW",
          "loss_function": "binary_crossentropy"
        }
      }
    },
    "small_ml_project": {
      "classification": {
        "architecture": {
          "input_layer": "Dense with input_dim = n_features",
          "hidden_layers": [
            "Dense(64, activation='relu', dropout=0.2)",
            "Dense(32, activation='relu', dropout=0.2)"
          ],
          "output_layer": "Dense(n_classes, activation='softmax')"
        },
        "hyperparameters": {
          "epochs": 50,
          "batch_size": 32,
          "learning_rate": 0.001,
          "optimizer": "Adam",
          "loss_function": "categorical_crossentropy"
        }
      },
      "regression": {
        "architecture": {
          "input_layer": "Dense with input_dim = n_features",
          "hidden_layers": [
            "Dense(64, activation='relu', dropout=0.2)",
            "Dense(32, activation='relu', dropout=0.2)"
          ],
          "output_layer": "Dense(1, activation='linear')"
        },
        "hyperparameters": {
          "epochs": 50,
          "batch_size": 32,
          "learning_rate": 0.001,
          "optimizer": "Adam",
          "loss_function": "mse"
        }
      }
    }
  },
  "gradient_boosting": {
    "xgboost": {
      "hyperparameters": {
        "n_estimators": 100,
        "max_depth": 6,
        "learning_rate": 0.1,
        "subsample": 0.8,
        "colsample_bytree": 0.8,
        "random_state": 42
      },
      "tuning_space": {
        "n_estimators": [50, 100, 200, 300],
        "max_depth": [3, 4, 5, 6, 7],
        "learning_rate": [0.01, 0.05, 0.1, 0.2],
        "subsample": [0.6, 0.7, 0.8, 0.9, 1.0],
        "colsample_bytree": [0.6, 0.7, 0.8, 0.9, 1.0]
      }
    },
    "lightgbm": {
      "hyperparameters": {
        "n_estimators": 100,
        "max_depth": 6,
        "learning_rate": 0.1,
        "subsample": 0.8,
        "colsample_bytree": 0.8,
        "num_leaves": 31,
        "random_state": 42
      },
      "tuning_space": {
        "n_estimators": [50, 100, 200, 300],
        "max_depth": [3, 4, 5, 6, 7],
        "learning_rate": [0.01, 0.05, 0.1, 0.2],
        "num_leaves": [15, 31, 63, 127],
        "subsample": [0.6, 0.7, 0.8, 0.9, 1.0]
      }
    },
    "catboost": {
      "hyperparameters": {
        "iterations": 100,
        "depth": 6,
        "learning_rate": 0.1,
        "subsample": 0.8,
        "random_state": 42,
        "verbose": false
      },
      "tuning_space": {
        "iterations": [50, 100, 200, 300],
        "depth": [3, 4, 5, 6, 7],
        "learning_rate": [0.01, 0.05, 0.1, 0.2],
        "subsample": [0.6, 0.7, 0.8, 0.9, 1.0]
      }
    }
  },
  "traditional_ml": {
    "random_forest": {
      "hyperparameters": {
        "n_estimators": 100,
        "max_depth": null,
        "min_samples_split": 2,
        "min_samples_leaf": 1,
        "random_state": 42
      },
      "tuning_space": {
        "n_estimators": [50, 100, 200, 300],
        "max_depth": [3, 5, 7, 10, null],
        "min_samples_split": [2, 5, 10, 20],
        "min_samples_leaf": [1, 2, 4, 8]
      }
    },
    "svm": {
      "hyperparameters": {
        "C": 1.0,
        "kernel": "rbf",
        "gamma": "scale",
        "random_state": 42
      },
      "tuning_space": {
        "C": [0.1, 1, 10, 100],
        "kernel": ["linear", "rbf", "poly"],
        "gamma": ["scale", "auto", 0.001, 0.01, 0.1, 1]
      }
    },
    "logistic_regression": {
      "hyperparameters": {
        "C": 1.0,
        "penalty": "l2",
        "solver": "lbfgs",
        "random_state": 42
      },
      "tuning_space": {
        "C": [0.01, 0.1, 1, 10, 100],
        "penalty": ["l1", "l2", "elasticnet"],
        "solver": ["lbfgs", "liblinear", "saga"]
      }
    },
    "knn": {
      "hyperparameters": {
        "n_neighbors": 5,
        "weights": "uniform",
        "algorithm": "auto"
      },
      "tuning_space": {
        "n_neighbors": [3, 5, 7, 9, 11, 15, 20],
        "weights": ["uniform", "distance"],
        "algorithm": ["auto", "ball_tree", "kd_tree", "brute"]
      }
    }
  },
  "clustering": {
    "kmeans": {
      "hyperparameters": {
        "n_clusters": 8,
        "init": "k-means++",
        "max_iter": 300,
        "random_state": 42
      },
      "tuning_space": {
        "n_clusters": [2, 3, 4, 5, 6, 7, 8, 9, 10],
        "init": ["k-means++", "random"]
      }
    },
    "dbscan": {
      "hyperparameters": {
        "eps": 0.5,
        "min_samples": 5
      },
      "tuning_space": {
        "eps": [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],
        "min_samples": [2, 3, 4, 5, 6, 7, 8, 9, 10]
      }
    },
    "agglomerative": {
      "hyperparameters": {
        "n_clusters": 8,
        "linkage": "ward"
      },
      "tuning_space": {
        "n_clusters": [2, 3, 4, 5, 6, 7, 8, 9, 10],
        "linkage": ["ward", "complete", "average", "single"]
      }
    }
  },
  "optimization": {
    "hyperparameter_tuning": {
      "grid_search": {
        "description": "Exhaustive search over specified parameter values",
        "pros": ["Guaranteed to find best parameters", "Simple to implement"],
        "cons": ["Computationally expensive", "Limited to discrete values"]
      },
      "random_search": {
        "description": "Random sampling from parameter space",
        "pros": ["Faster than grid search", "Can handle continuous parameters"],
        "cons": ["May miss optimal parameters", "Less systematic"]
      },
      "bayesian_optimization": {
        "description": "Uses Bayesian inference to guide search",
        "pros": ["Efficient exploration", "Handles continuous parameters"],
        "cons": ["More complex", "Requires more iterations"]
      },
      "optuna": {
        "description": "Automated hyperparameter optimization",
        "features": [
          "TPE sampler",
          "Pruning",
          "Parallel optimization",
          "Visualization"
        ]
      }
    },
    "cross_validation": {
      "k_fold": {
        "k": 5,
        "description": "5-fold cross-validation"
      },
      "stratified_k_fold": {
        "k": 5,
        "description": "Stratified 5-fold cross-validation for classification"
      },
      "time_series_split": {
        "n_splits": 5,
        "description": "Time series cross-validation"
      }
    }
  },
  "evaluation_metrics": {
    "classification": {
      "accuracy": "Overall correctness",
      "precision": "True positives / (True positives + False positives)",
      "recall": "True positives / (True positives + False negatives)",
      "f1_score": "Harmonic mean of precision and recall",
      "auc_roc": "Area under ROC curve",
      "auc_pr": "Area under Precision-Recall curve",
      "confusion_matrix": "True vs predicted classification matrix"
    },
    "regression": {
      "mse": "Mean Squared Error",
      "mae": "Mean Absolute Error",
      "rmse": "Root Mean Squared Error",
      "r2": "Coefficient of determination",
      "adjusted_r2": "Adjusted R-squared",
      "pearson_r": "Pearson correlation coefficient"
    },
    "clustering": {
      "silhouette_score": "Measures how similar an object is to its own cluster",
      "calinski_harabasz": "Ratio of between-cluster to within-cluster dispersion",
      "davies_bouldin": "Average similarity ratio of clusters",
      "inertia": "Sum of squared distances to centroids"
    }
  },
  "model_interpretation": {
    "feature_importance": {
      "tree_based": "Built-in feature importance from tree models",
      "permutation": "Permutation-based feature importance",
      "shap": "SHapley Additive exPlanations",
      "lime": "Local Interpretable Model-agnostic Explanations"
    },
    "partial_dependence": {
      "description": "Effect of a feature on predictions",
      "usage": "Understanding feature effects"
    },
    "ice_plots": {
      "description": "Individual Conditional Expectation plots",
      "usage": "Individual feature effects"
    }
  }
}
